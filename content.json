[{"title":"MyLife","date":"2017-01-16T11:55:18.000Z","path":"2017/01/16/MyLife/","text":"12345见自己 见天地见众生可惜自己见不了‘天地’与‘众生’‘见自己’已难得可贵","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"SHELL笔记 01","date":"2017-01-16T11:26:37.000Z","path":"2017/01/16/SHELL笔记-01/","text":"[toc] 简介1. 终端提示符 $表示普通用户 #表示管理员root12username@hostname $ root@hostname # &ensp; 2. shell脚本通常是以shebang(#!)起始的文本文件 shebang是一个文本行，其中#!位于解释器路径之前。/bin/bash是Bash的解释器命令路径。1#!/bin/bash &ensp;3. 运行脚本的方式 将脚本作为bash的命令行参数 123$ bash script.sh #假设脚本位于当前目录下 $ bash /home/path/script.sh #使用script.sh的完整路径# 如果将脚本作为bash的命令行参数来运行，那么就用不着脚本中的shebang 另一种是授予脚本执行权限，将其变为可执行文件。1234$ #该命令赋予所有用户script.sh文件的可执行权限。$ chmod a+x script.sh# 这个脚本能以下列方式执行：$ ./script.sh || /home/path/script.sh &ensp;4. 启动shell说明 启动shell时，它一开始会执行一组命令来定义诸如提示文本、颜色等各类设置。 这组命令来自位于用户主目录中的脚本文件~/.bashrc（对于登录shell则是~/.bash_profile）。 Bash还维护了一个历史记录文件~/.bash_history，用于保存用户运行过的命令。 &ensp;5. 在Bash中，每个命令或是命令序列是通过使用分号或换行符来分隔 12345$ cmd1 ; cmd2$ # 它等同于：$ cmd1$ cmd2 &ensp;6. 注释 注释部分以#为起始，一直延续到行尾。 终端打印echo 在默认情况下，echo在每次调用后会添加一个换行符\\n1234567$ #使用/不使用双引号 $ echo &quot;Welcome to Bash&quot; || echo Welcome to BashWelcome to Bash$ #使用单引号$ echo &apos;Welcome to Bash&apos;Welcome to Bash 这些方法看起来相似，但各有一些特殊用途和副作用。思考下面这行命令：123456789# 以下命令基于centos 6.5 环境下执行[root@lucia test]# echo hello world ! # ①hello world ![root@lucia test]# echo &quot;hello world !&quot; # ②-bash: !&quot;: event not found[root@lucia test]# echo &quot;hello world ! &quot; # ③hello world ! [root@lucia test]# echo &apos;hello world !&apos; # ④hello world ! 用echo命令输出不加引号的字符串时，将字符串中的各个单词作为字符串输出，各字符串之间用一个空格分割。①成功输出 ! 当后面跟随的字母不是“空格、换行、回车、=和(”时，做命令替换。故而②报错，③成功输出 当shell碰到第一个单引号时，它忽略掉其后右引号的所有特殊字符。故而④成功输出 不加引号和加引号的区别： 12345[root@lucia test]# echo hello;worldhello-bash: world: command not found[root@lucia test]# echo &quot;hello;world&quot;hello;world tips:使用不带引号的echo时，无法再所要显示的文本中使用分号(;)，分号在Bash shell中用作命令定界符 单引号和双引号的区别：1234567[root@lucia test]# var1=hello[root@lucia test]# var2=world[root@lucia test]# echo &quot;$var1 $var2&quot;hello world[root@lucia test]# echo &apos;$var1 $var2&apos;$var1 $var2[root@lucia test]# 单引号（’ ‘）和双引号类似，但它不允许解释变量引用，因此，在单引号内的字符$的特殊意思无效了。 在单引号内，除了字符’，每个特殊字符都只是字面的意思。 单引号（全局引用）比双引号（部分引用）更严格的处理引用部分。 &ensp; 在echo中转义换行符 选项-n来忽略结尾的换行符。 转义序列参数echo –e “包含转义序列的字符串”这种形式12echo -e &quot;1\\t2\\t3&quot;1 2 3 打印彩色输出颜色设置:重置=0,其中“F”为字体颜色，编号30 ~ 37；“B”为背景色，编号40~47 123456789F B30 40 黑色31 41 红色32 42 绿色33 43 黄色34 44 蓝色35 45 紫红色36 46 青蓝色37 47 白色 要打印彩色文本，可输入如下命令： 12echo -e &quot;\\e[1;31m This is red text \\e[0m&quot;# \\e[1;31将颜色设为红色，\\e[0m将颜色重新置回 要设置彩色背景，可输入如下命令： 1echo -e &quot;\\e[1;42m Green Background \\e[0m&quot; &ensp; printf printf并不像echo命令自动添加换行符\\n,但可以通过各种参数在printf中使用格式化字符串 1$ printf &quot;Hello world&quot; 比如在下面的脚本中：123456#!/bin/bash#文件名: printf.shprintf &quot;%-5s %-10s %-4s\\n&quot; No Name Markprintf &quot;%-5s %-10s %-4.2f\\n&quot; 1 Sarath 80.3456printf &quot;%-5s %-10s %-4.2f\\n&quot; 2 James 90.9989printf &quot;%-5s %-10s %-4.2f\\n&quot; 3 Jeff 77.564 我们会得到如下格式化的输出：1234No Name Mark1 Sarath 80.352 James 91.003 Jeff 77.56 %s、%c、%d和%f都是格式替换符（format substitution character），其所对应的参数可以置于带引号的格式字符串之后。 -表示左对齐，默认字符串采用右对齐方式 -Xs指明了一个格式为左对齐且宽度为X的字符串替换,宽度指定了保留给某个变量的字符数。如果内容不足X个字符，余下的则以空格符填充。 对于浮点数，可以使用其他参数对小数部分进行舍入。对于Mark字段，将其格式化为%-4.2f，其中.2指定保留2个小数位。 注意，在每行格式字符串后都有一个换行符（\\n）。 变量和环境变量概念小结 在Bash中，每一个变量的值都是字符串，值都以字符串的形式存储 环境变量：一些特殊的变量会被shell环境和操作系统环境用来存储特别的值 env查看所有与终端相关的环境变量 123456[root@lucia tmp]# envHOSTNAME=luciaSELINUX_ROLE_REQUESTED=TERM=xtermSHELL=/bin/bash... 对于进程A，其运行时环境变量12PID=`pgrep A`cat /proc/$PID/environ 1234567[root@lucia tmp]# cat /proc/1/environ HOME=/TERM=linuxPATH=/sbin:/bin:/usr/sbin:/usr/bin[root@lucia tmp]# cat /proc/1/environ | tr &apos;\\0&apos; \\n&apos;HOME=/TERM=linuxPATH=/sbin:/bin:/usr/sbin:/usr/bin 每一个变量以name=value的形式描述，用null字符（\\O）分隔将\\0替换\\n，重新输出格式化，每一行显示一组“变量=值” 环境变量是未在当前进程中定义，而从父进程中继承而来的变量 export命令用来设置环境变量临时变量（当前shell脚本执行的任何应用程序都会继承这个变量） &ensp; 标准环境变量PATH类似于下面的格式：12[root@lucia tmp]# echo $PATH/usr/local/ruby/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin:/usr/local/git/bin:/root/bin 在给出所要执行的命令后，shell会自动在PATH环境变量所包含的目录列表中（各目录路径之间以冒号分隔）查找对应的可执行文件。 PATH通常定义在/etc/environment或/etc/profile或~/.bashrc中。 如果需要在PATH中添加一条新路径，可以使用：123456$ export PATH=&quot;$PATH:/home/user/bin&quot;$ # 或者$ PATH=&quot;$PATH:/home/user/bin&quot;$ export PATH &ensp; 使用函数添加环境变量假设我们要将myapp安装到/opt/myapp，它的二进制文件在bin目录中，库文件在lib目录中。 实现方法如下：12export PATH=/opt/myapp/bin:$PATHexport LD_LIBRARY_PATH=/opt/myapp/lib:$LD_LIBRARY_PATH PATH和LD_LIBRARY_PATH现在看起来应该像这样：12PATH=/opt/myapp/bin:/usr/bin:/binLD_LIBRARY_PATH=/opt/myapp/lib:/usr/lib:/lib 不过我们可以把下面的函数加入.bashrc，让一切变得更轻松些：1prepend() &#123; [ -d &quot;$2&quot; ] &amp;&amp; eval $1=\\&quot;$2&apos;:&apos;\\$$1\\&quot; &amp;&amp; export $1; &#125; 像下面这样来使用该函数：12prepend PATH /opt/myapp/binprepend LD_LIBRARY_PATH /opt/myapp/lib 工作原理 我们定义了名为prepend()的函数，它首先检查该函数第二个参数所指定的目录是否存在。 如果存在，eval表达式将第一个参数所指定的变量值设置成第二个参数的值加上“:”（路径分隔符），随后再跟上首个参数的原始值。 有一点需要留意。在进行添加时，如果变量为空，则会在末尾留下一个“:”要解决这个问题，可以将该函数再进行一些修改：1prepend() &#123; [ -d &quot;$2&quot; ] &amp;&amp; eval $1=\\&quot;$2\\$\\&#123;$1:+&apos;:&apos;\\$$1\\&#125;\\&quot; &amp;&amp; export $1 ; &#125; 在这个函数中，我们引入了一种shell参数扩展的形式：1$&#123;parameter:+expression&#125; 如果parameter有值且不为空，则使用expression的值。通过这次修改，在追加环境变量时，当且仅当旧值存在，才会增加。 tips: eval cmdline : eval会对后面的cmdline进行两遍扫描，第一次cmdline若为普通命令，则执行此命令，若含有变量的间接引用，替换间接引用的语义 例如输出最后一个参数1234567[root@lucia ~]# set 11 22 33 44[root@lucia ~]# echo &quot;$#&quot;4[root@lucia ~]# echo &quot;\\$$#&quot;$4[root@lucia ~]# eval echo &quot;\\$$#&quot;44 eval命令将会首先扫描命令行进行所有的替换，然后再执行命令。该命令使用于那些一次扫描无法实现其功能的变量 &ensp; 补充知识识别当前使用的shell1echo $shell || echo $0 &ensp; 检查是否为超级用户1234567#!/bin/bashif [ $UID -ne 0 ];then echo Non root user.Please run as root.else echo Root user.fi &ensp; 修改Bash提示字符串（username@hostname:~$） 利用PS1(Prompt Sign)环境变量来定制提示文本 默认的shell提示文本是在文件~/.bashrc中的某一行设置的 12[root@lucia ~]# echo $PS1[\\u@\\h \\W]\\$ \\u可以扩展为用户名\\h可以扩展为主机名\\w可以扩展为当前工作目录 颜色设置在PS1中设置字符序列颜色的格式为：[\\e[F;Bm]其中“F”为字体颜色，编号30 ~ 37；“B”为背景色，编号40~47 颜色表：123456789F B30 40 黑色31 41 红色32 42 绿色33 43 黄色34 44 蓝色35 45 紫红色36 46 青蓝色37 47 白色 123[root@lucia ~]# export PS1=&apos;[\\[\\e[32;40m\\]\\u@\\h \\w]\\$&apos;[root@lucia ~]# #提示符变成绿字黑底 定制提示字符串12[root@lucia ~]#PS1=&quot;PROMPT&gt;&quot;PROMPT&gt; Type commands here #提示字符串已经改变 &ensp; 使用shell进行数字运算获取字符串长度12length=$&#123;#var&#125;#length 表示字符串所包含的字符数 123$ var=12345678901234567890$ echo $&#123;#var&#125;20 &ensp; 基本算术（整数）操作举例123#!/bin/bashno1=4;no2=5; 操作符 let12let result=no1+no2echo $result 附：自增自减/简写形式12let no1++ || let no1--let no+=6 || let no-=6 &ensp; 操作符 [ ]1result=$[ no1 + no2 ] || result=$[ $no1 + 5 ] &nesp; 操作符 (())使用(())时，变量名之前需要加上$：1result=$(( no1 + 50 )) &nesp; 操作符 exprexpr同样可以用于基本算术操作：12result=`expr 3 + 4`result=$(expr $no1 + 5) 以上这些方法只能用于整数运算，而不支持浮点数。 高级算术操作操作符 bc bc是一个用于数学运算的高级工具，这个精密计算器包含了大量的选项。我们可以借助它执行浮点数运算并应用一些高级函数：12echo &quot;4 * 0.56&quot; | bc2.24 1234no=54;result=`echo &quot;$no * 1.5&quot; | bc`echo $result81.0 设定小数精度 参数scale=2将小数位个数设置为2，bc将会输出包含两个小数位的数值。12echo &quot;scale=2;3/8&quot; | bc0.37 进制转换 用bc可以将一种进制系统转换为另一种 12345678#!/bin/bash#用途：数字转换no=100echo &quot;obase=2;$no&quot; | bc #十进制转换成二进制1100100no=1100100echo &quot;obase=10;ibase=2;$no&quot; | bc #二进制转换回十进制100 计算平方以及平方根12echo &quot;sqrt(100)&quot; | bc echo &quot;10^10&quot; | bc 文件描述符及重定向文件描述符说明文件描述符是与某个打开的文件或数据流相关联的整数，文件描述符0、1以及2是系统预留的。 0 —— stdin（标准输入） 1 —— stdout（标准输出） 2 —— stderr（标准错误） 文件打开3种模式 只读模式 &lt; 操作符用于从文件中读取至stdin 截断写入模式 > 操作符用于截断模式的文件写入（数据在目标文件内容被截断之后写入) 追加写入模式 >&gt;操作符用于追加模式的文件写入 123$ # 当命令输出错误信息时，stderr信息就会被打印出来$ ls +ls: cannot access +: No such file or directory 这里，+是一个非法参数，因此将返回错误信息。 1234$ # 下面的命令会将stderr文本打印到屏幕上，而不是文件中（而且因为并没有stdout的输出，所以out.txt没有内容）$ ls + &gt; out.txt ls: cannot access +: No such file or directory 12$ # 下面的命令中，我们将stderr重定向到out.txt：$ ls + 2&gt; out.txt #正常运行 你可以将stderr单独重定向到一个文件，将stdout重定向到另一个文件：1$ cmd 2&gt;stderr.txt 1&gt;stdout.txt 还可以利用下面这个更好的方法将stderr转换成stdout，使得stderr和stdout都被重定向到同一个文件中：1$ cmd &gt; output.txt 2&gt;&amp;1 || cmd &amp;&gt; output.txt tee既可以将数据重定向到文件，还可以提供一份重定向数据的副本作为后续命令的stdin 要在终端中打印stdout，同时将它重定向到一个文件中，那么可以这样使用tee:1command | tee FILE1 FILE2 在下面的代码中，tee命令接收到来自stdin的数据。它将stdout的一份副本写入文件out.txt，同时将另一份副本作为后续命令的stdin。命令cat -n将从stdin中接收到的每一行数据前加上行号并写入stdout:1234$ cat a* | tee out.txt | cat -ncat: a1: Permission denied1 a12 a1 查看out.txt的内容：123$ cat out.txta1a1 注意，cat: a1: Permission denied 并没有在文件内容中出现。这是因为这些信息属于stderr，而tee只能从stdin中读取 文件重定向到命令借助重定向，我们可以像使用stdin那样从文件中读取数据：1$ cmd &lt; file 脚本内部的文本块进行重定向对文本块（多行文本）进行重定向，源文本就位于shell脚本中。一个实用的例子是向log文件中写入头部数据123456#!/bin/bashcat&lt;&lt;EOF&gt;log.txtLOG FILE HEADERThis is a test log fileFunction: System statisticsEOF 在cat &lt;log.txt与下一个EOF行之间的所有文本行都会被当做stdin数据。log.txt文件的内容打印如下：1234$ cat log.txtLOG FILE HEADERThis is a test log fileFunction: System statistics 自定义描述符使用exec命令创建自己的文件描述符创建一个文件描述符进行文件读取：1$ exec 3&lt;input.txt #使用文件描述符3打开并读取文件 我们可以这样使用它：12$ echo this is a test line &gt; input.txt$ exec 3&lt;input.txt 现在你就可以在命令中使用文件描述符3了。例如：12$ cat&lt;&amp;3this is a test line 如果要再次读取，我们就不能继续使用文件描述符3了，而是需要用exec重新分配文件描述符3来进行二次读取。 创建一个文件描述符用于写入（截断模式）：1$ exec 4&gt;output.txt #打开文件进行写入 例如：1234$ exec 4&gt;output.txt$ echo newline &gt;&amp;4$ cat output.txtnewline 创建一个文件描述符用于写入（追加模式）：1$ exec 5&gt;&gt;input.txt 例如：12345$ exec 5&gt;&gt;input.txt$ echo appended line &gt;&amp;$ cat input.txtnewlineappended line 数组和关联数组数组是shell脚本非常重要的组成部分，它借助索引将多个独立的数据存储为一个集合。普通数组只能使用整数作为数组索引。关联数组可以使用字符串作为数组索引。 数组的说明(1) 定义数组的方法有很多种。可以在单行中使用一列值来定义一个数组：12array_var=(1 2 3 4 5 6)#这些值将会存储在以0为起始索引的连续位置上 另外，还可以将数组定义成一组“索引-值”：123456array_var[0]=&quot;test1&quot;array_var[1]=&quot;test2&quot;array_var[2]=&quot;test3&quot;array_var[3]=&quot;test4&quot;array_var[4]=&quot;test5&quot;array_var[5]=&quot;test6&quot; (2) 打印出特定索引的数组元素内容：12345echo $&#123;array_var[0]&#125;test1index=5echo $&#123;array_var[$index]&#125;test6 (3) 以清单形式打印出数组中的所有值：12$ echo $&#123;array_var[*]&#125; || echo $&#123;array_var[@]&#125; test1 test2 test3 test4 test5 test6 (4) 打印数组长度（即数组中元素的个数）：12$ echo $&#123;#array_var[*]&#125;`6 定义关联数组声明语句将一个变量名声明为关联数组1$ declare -A ass_array 声明之后，可以用两种方法将元素添加到关联数组中。  利用内嵌“索引-值”列表的方法，提供一个“索引-值”列表：1$ ass_array=([index1]=val1 [index2]=val2)  使用独立的“索引-值”进行赋值：12$ ass_array[index1]=val1$ ass_array&apos;index2]=val2 举个例子，试想如何用关联数组为水果制定价格：12$ declare -A fruits_value$ fruits_value=([apple]=&apos;100dollars&apos; [orange]=&apos;150 dollars&apos;) 用下面的方法显示数组内容：12$ echo &quot;Apple costs $&#123;fruits_value[apple]&#125;&quot;Apple costs 100 dollars 列出数组索引每一个数组元素都有一个索引用于查找。普通数组和关联数组具有不同的索引类型。我们可以用下面的方法获取数组的索引列表：1$ echo $&#123;!array_var[*]&#125; || echo $&#123;!array_var[@] 以先前提到的fruits_value数组为例，运行如下命令：12$ echo $&#123;!fruits_value[*]&#125;orange apple 对于普通数组，这个方法同样可行。 使用别名别名就是一种便捷方式，以省去用户输入一长串命令序列的麻烦。alias命令创建别名。 可以按照下面的方式创建一个别名： 1$ alias new_command=&apos;command sequence&apos; 为安装命令apt-get install创建别名： 1$ alias install=&apos;sudo yum install&apos; 这样一来，我们就可以用install pidgin代替sudo yum install pidgin了。 alias命令的作用只是暂时的。一旦关闭当前终端，所有设置过的别名就失效了。为了使别名设置一直保持作用，可以将它放入~/.bashrc文件中。因为每当一个新的shell进程生成时，都会执行 ~/.bashrc中的命令。1$ echo &apos;alias cmd=&quot;command seq&quot;&apos; &gt;&gt; ~/.bashrc 删除别名，只用将其对应的语句（如果有的话）从 ~/.bashrc中删除，或者使用unalias命令。或者使用alias example=，这会取消名为example的别名。 我们可以创建一个别名rm，它能够删除原始文件，同时在backup目录中保留副本： alias rm=’cp $@ ~/backup &amp;&amp; rm $@’ (错误命令,请勿效仿) 正确设置如下：12alias saferm=&apos;saferm()&#123;cp $@ ~/backup; rm $@;&#125;;saferm $@&apos;saferm abc.txt 如果命令比较复杂，建议写出shell脚本搜索1234#! /bin/sh# /home/yourname/safermcp $@ ~/backuprm $@ 然后建立一个alias12chmod +x /home/yourname/safermalias saferm=/home/yourname/saferm 创建别名时，如果已经有同名的别名存在，那么原有的别名设置将被新的设置取代。 alias命令能够为任何重要的命令创建别名，不过你未必总是希望用别名来执行这个命令。我们可以将希望使用的命令进行转义，从而忽略当前定义的别名。例如：1$ \\command 字符\\对命令实施转义，使我们可以执行原本的命令，而不是这些命令的别名替身。 调试脚本 使用选项–x，启用shell脚本的跟踪调试功能： 12$ bash -x script.sh# 打印出脚本所执行的每一行命令以及当前状态 使用set -x和set +x对脚本进行部分调试。例如： 123456789#!/bin/bash#文件名: debug.shfor i in &#123;1..6&#125;;doset -xecho $iset +xdoneecho &quot;Script executed&quot; 在上面的脚本中，只会打印出echo $i的调试信息，因为使用了-x和+x对调试区域 set –x：在执行时显示参数和命令。 set +x：禁止调试。 set –v：当命令进行读取时显示输入。 set +v：禁止打印输入。 shebang从#!/bin/bash改成 #!/bin/bash -xv，这样一来，不用任何其他选项就可以启用调试功能了 自定义格式显示调试信息这可以通过传递 _DEBUG环境变量来建立这类调试风格。 123456789#!/bin/bashfunction DEBUG()&#123;[ &quot;$_DEBUG&quot; == &quot;on&quot; ] &amp;&amp; $@ || :&#125;for i in &#123;1..10&#125;doDEBUG echo $idone 我们在每一个需要打印调试信息的语句前加上DEBUG。如果没有把 _DEBUG=on传递给脚本，那么调试信息就不会打印出来。在Bash中，命令“:”告诉shell不要进行任何操作（占位符）。123456789101112[root@lucia test]# _DEBUG=on ./debug.sh 12345678910[root@lucia test]# ./debug.sh","tags":[{"name":"SHELL笔记","slug":"SHELL笔记","permalink":"http://yoursite.com/tags/SHELL笔记/"}]},{"title":"搭建hexo主题博客","date":"2017-01-16T05:56:33.000Z","path":"2017/01/16/搭建hexo主题博客/","text":"[toc] 简要相关说明 Github Pages 实现静态网页部署 Hexo主题美化博客 实现目标 博客生成 域名绑定 双线路 博客备份 准备工作 安装msysgit 安装Node.js 搭建 命令行操作均在Git Bash下进行 Hexo安装 Hexo12345$ # 更换 taobao的npm源npm install -g cnpm --registry=https://registry.npm.taobao.org$ # 安装 hexo$ npm install hexo-cli -g$ npm install hexo --save 初始化 Hexo12345$ # 新建 Hexo文件夹$ mkdir X:/yourfile/Hexo$ # 初始化$ hexo init$ npm install 安装 Hexo插件12345678910111213npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --save 查看Hexo 本地效果12hexo generate || hexo ghexo server || hexo s 效果url：localhost:4000 博客部署Github Pages配置Github 注册Github账户（Sign Up） 创建项目仓库New repository 仓库名称必须为 username.github.io 初始化仓库 配置SSH密钥 实现本地代码库通过git操作与远端Github代码库同步 1[ -d ~/.ssh ] &amp;&amp; clip &lt; ~/.ssh/id_rsa.pub^C| ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 存在SSH密钥则将公钥的内容复制到系统粘贴板(clipboard)，否则创建密钥 创建密钥过程中，提示输密码直接回车 登录Github → Account Setting → SSH keys and GPG keys → Add SSH key 测试设置成功与否 1$ ssh -T git@github.com 用户信息设置12git config --global user.name &quot;XXXX&quot;$ git config --global user.email &quot;XXXX@gmail.com&quot; Hexo 更新到Github 仓库 配置项 _config.yml (X:\\yourfile\\Hexo) 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:xxxx/xxxx.github.io.git branch: master 执行命令进行部署 1hexo g -d xxxx.github.io 进行访问即可 扩展Hexo 相关更换主题 Hexo 官网主题 本博客使用的是 yilia 主题 安装 （X:\\yourfile\\Hexo\\themes 下） 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 配置 12# 修改hexo根目录下的 _config.yml_config.yml ： theme: yilia 更新12cd themes/yiliagit pull Hexo 命令域名关联域名（简单粗暴） \\hexo\\source 文件夹下创建文件 CNAME 并提交 12echo www.xxxx.xxx &gt; CNAMEhexo g -d 添加记录 1CNAME WWW xxxx.github.io 注意:这个简单粗暴指的是操作简单，但是有些浏览器无法解析。比如谷歌和火狐能顺利打开网页，但是360浏览器表示有点方，一直404 关联域名 （DNSPOD） \\hexo\\source 文件夹下创建文件 CNAME 并提交 12echo xxxx.xxx &gt; CNAMEhexo g -d 修改域名提供商提供的DNS 12f1g1ns2.dnspod.net f1g1ns1.dnspod.net 使用DNSPOD 账户添加域名解析 12www A 默认 IP Address@ A 默认 IP Address Lucia’note 博客搭建在github与gitcafe上，域名解析哪个快走哪个 博客备份在git@osc 博客备份 删除文件夹内原有的.git缓存文件(以防造成仓库冲突) 1[ -d .git ] &amp;&amp; rm .git 编辑.gitignore(指定忽略文件） 123/.deploy_git #hexo默认的.git配置文件夹/public #根据source文件夹内容自动生成/_config.yml #配置文件含重要信息 初始化仓库并添加远程仓库 12git initgit remote add origin &lt;server&gt; 添加本地文件提交说明到仓库并同步到远端仓库 123git add . git commit -m &quot;first commit&quot; git push -u origin master 更新同步操作 123git add .git commit -m &apos;更新信息&apos;git push 拉取备份文件 123456git initgit remote add origin &lt;server&gt; git fetch --allgit reset --hard origin/master# 更新后拉取git pull 博客搭建成功—致谢以下道友的辛苦探路 https://my.oschina.net/ryaneLee/blog/638440https://segmentfault.com/a/1190000003710980https://segmentfault.com/a/1190000003710962https://segmentfault.com/a/1190000003710962","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"mysql5.6.zip 安装","date":"2016-12-05T12:52:31.000Z","path":"2016/12/05/mysql/","text":"[TOC] 准备工作 mysql5.6 下载地址 http://dev.mysql.com/downloads/mysql/5.6.html 安装过程解压缩重命名 解压缩在C盘某个文件夹下并重命名为MySQL SERVER 5.6(便于记忆) mysql-5.6.34-winx64 → MySQL SERVER 5.6(或mysql56) 设置环境变量 此电脑→高级系统设置→高级→环境变量→PATH→编辑→编辑文本追加 ;C:\\Program Files (x86)\\MySQL\\MySQL Server 5.6\\bin\\; 修改配置文件 配置文件：MySQL Server 5.6\\my-default.ini 添加配置如代码框中所示12345678910111213141516171819202122232425262728293031323334353637# For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html# *** DO NOT EDIT THIS FILE. It&apos;s a template which will be copied to the# *** default location during install, and will be replaced if you# *** upgrade to a newer version of MySQL.[mysqld]# Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M# Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin# These are commonly set, remove the # and set as required.# basedir = .....# datadir = .....# port = .....# server_id = .....#--- 添加配置如下 ---## mysql所在目录basedir = C:\\Program Files (x86)\\MySQL\\MySQL Server 5.6# mysql所在目录\\datadatadir = C:\\Program Files (x86)\\MySQL\\MySQL Server 5.6\\data# Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2M sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 以管理员身份运行cmd（否则会因权限不够报错 Install/Remove of the Service Denied!） 123C:\\Users\\lucia\\Desktop&gt;cd C:\\Program Files (x86)\\MySQL\\MySQL Server 5.6\\bin\\C:\\Program Files (x86)\\MySQL\\MySQL Server 5.6\\bin&gt;mysql -install 必须进入bin文件夹，否则启动服务会报错 发生系统错误 2","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"windows10","slug":"windows10","permalink":"http://yoursite.com/tags/windows10/"}]},{"title":"git","date":"2016-12-03T07:25:14.000Z","path":"2016/12/03/git/","text":"","tags":[]},{"title":"Linux源代码安装Git及其他附录","date":"2016-11-24T02:01:08.000Z","path":"2016/11/24/sourcecodeGIT/","text":"[TOC] 环境说明： OS：CentOS-6.5.mininal (NULL) GIT：git version 2.8.2 NULL特指什么软件都未安装（纯净版）1[2] OS 新建了一个用户 xiaolu 准备工作：安装 EPEL源根据CentOS的版本下载不同的镜像 ( 使用的是国内的EPEL源-科大源）12345678[root@lucia ~]# su xiaolu[xiaolu@lucia root]$ cd /etc/yum.repos.d/[xiaolu@lucia yum.repos.d]$ sudo yum -y install wget[xiaolu@lucia yum.repos.d]$ sudo mv CentOS-Base.repo CentOS-Base.repo.bak[xiaolu@lucia yum.repos.d]$ sudo wget -O CentOS-Base.repo https://lug.ustc.edu.cn/wiki/_export/code/mirrors/help/centos?codeblock=2 # wget -O --output-document=FILE 指定下载目录和文件名[xiaolu@lucia yum.repos.d]$ yum makecache#附-科大源：https://lug.ustc.edu.cn/wiki/mirrors/help/centos 时间校准123456789[xiaolu@lucia yum.repos.d]$ cd /tmp[xiaolu@lucia tmp]$ sudo yum -y install ntpdate.x86_64[xiaolu@lucia tmp]$ sudo ntpdate 0.pool.ntp.org 1 Apr 16:40:49 ntpdate[7329]: no server suitable for synchronization found---------------------------------------------------------------------------------[xiaolu@lucia tmp]$ sudo yum -y install rdate.x86_64[xiaolu@lucia tmp]$ sudo rdate -s time.nist.gov[xiaolu@lucia tmp]$ dateSun May 1 23:17:19 CST 2016 注：ntpdate校准报错选择rdate（很可能是防火墙封锁了udp的123端口, 如果关闭的防火墙问题依旧, 很可能是上层路由的设置有问题, 如果这种情况, 我们就只能通过tcp来更新时间） 安装Git（ 源代码安装）Step 1: 安装所需的依赖包源代码编译GIT之前，确保系统安装了所需的包或者通过以下命令来安装它12[xiaolu@lucia tmp]$ sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-ExtUtils-MakeMaker package -y[xiaolu@lucia tmp]$ sudo yum -y install gcc (下载 编译器 ) Step 2：下载并编译GIT源代码 ‍‍从 git-scm 下载最新Git源代码或者简单的使用以下载命令下载Git 2.8.212345678[xiaolu@lucia tmp]$ sudo wget -c https://www.kernel.org/pub/software/scm/git/git-2.8.2.tar.gz[xiaolu@lucia tmp]$ tar -zxvf git-2.8.2.tar.gz [xiaolu@lucia tmp]$ cd git-2.8.2[xiaolu@lucia git-2.8.2]$ make prefix=/usr/local/git all[xiaolu@lucia git-2.8.2]$ sudo make prefix=/usr/local/git install[xiaolu@lucia git-2.8.2]$ su root[root@lucia git-2.8.2]# echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrc # 设置环境变量[root@lucia git-2.8.2]# source /etc/bashrc Step 3：核实GIT 版本完成以上步骤后，使用以下命令检查GIT版本12[xiaolu@lucia git-2.8.2]$ git --versiongit version 2.8.2 Step 4：命令补全Linux的shell环境通过bash-completion软件包提供命令补齐功能，在录入命令参数时按一次或两次TAB键可实现参数的自动补齐或提示12345678910111213141516171819[xiaolu@lucia git-2.8.2]$ sudo cp contrib/completion/git-completion.bash /etc/bash_completion.d/ #将Git源码包中的命令补全脚本肤质到bash-completion对应的目录中 [xiaolu@lucia git-2.8.2]$ . /etc/bash_completion.d/git-completion.bash #重新加载自动补齐脚本，使之在当前的shell中生效``` 为了能够在终端开启时自动加载脚本，需要修改/etc/profile文件和~/.bashrc文件```shell[root@lucia git-2.8.2]# sudo cat &gt;&gt; ~/.bashrc &lt;&lt;EOF&gt; if [ -f /etc/bash_completion.d/git-completion.bash ]; then&gt; . /etc/bash_completion.d/git-completion.bash&gt; fi&gt; EOF[xiaolu@lucia git-2.8.2]$ su root[root@lucia git-2.8.2]# sudo cat &gt;&gt; /etc/profile &lt;&lt;EOF&gt; if [ -f /etc/bash_completion.d/git-completion.bash ]; then&gt; . /etc/bash_completion.d/git-completion.bash&gt; fi&gt; EOF 附1：中文支持 相关说明：GIT可以在提交说明中使用中文，但是需要对Git进行配置但对于用中文来命名文件、目录和引用，前提是使用UTF-8 字符集的环境下‍ UTF8字符集：1、在提交时，可以在提交说明中输入中文2、显示提交历史，能够正常显示提交说明中的中文字符3、可以添加名称为中文的文件，并可以在同样使用UTF-8字符集的Linux环境中克隆和检出4、可以创建带有中文字符的里程碑名称 ❀ 在默认设置下，中文文件名在工作区状态输出、查看历史更改概要，以及在补丁文件中，文件名中的中文不能正确的显示，而是显示为八进制的字符编码，如下 1234[xiaolu@lucia rs-project]$ git status -s?? &quot;\\346\\265\\213\\350\\257\\225.txt&quot;[xiaolu@lucia rs-project]$ printf &quot;\\346\\265\\213\\350\\257\\225.txt\\n&quot;测试.txt ❀ 解决方法：通过将Git配置变量 core.quotepath 设置为 false 123[xiaolu@lucia rs-project]$ git config --global core.quotepath false[xiaolu@lucia rs-project]$ [xiaolu@lucia rs-project]$ git status -s?? 测试.txt 附2：相关问题make prefix=/usr/local/git all 报错目前我碰到的报错有两种： 时间没有校准（看见 in the future 就是时间没有校准，校准后重新make） 123456789101112ake[1]: Warning: File `Makefile&apos; has modification time 2.5e+06 s in the future/usr/bin/perl Makefile.PL PREFIX=&apos;/usr/local&apos; INSTALL_BASE=&apos;&apos; --localedir=&apos;/usr/local/share/locale&apos;Writing perl.mak for Gitmake[1]: warning: Clock skew detected. Your build may be incomplete. GEN git-add--interactivemake[1]: Warning: File `Makefile&apos; has modification time 2.5e+06 s in the futureWriting perl.mak for Gitmake[2]: Warning: File `Makefile.PL&apos; has modification time 2.5e+06 s in the futureWriting perl.mak for Gitmake[2]: *** [perl.mak] Error 1make[1]: *** [instlibdir] Error 2make: *** [git-add--interactive] Error 2 第二种报依赖包错误，导致make失败本文OS是纯净版，实际上真正OS环境下许多依赖包已经安装，且通过yum仓库安装的版本都较老，换yum源后将提示的相关依赖包卸载（rpm -e），然后重新yum安装一下","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"高性能集群软件-Keepalived","date":"2016-11-23T15:07:33.000Z","path":"2016/11/23/Keepalived/","text":"keepalived 介绍 keepalived 是 Linux下一个轻量级的高可用解决方案 keepalived 主要通过虚拟路由冗余（VRRP）来实现高可用功能 优点 部署及使用简单，只需一个配置文件即可完成 功能 服务器状态检测和故障隔离功能 HA（High Available） cluster &nbsp; [高可用群集] keepalived 发展 keepalived起初是为LVS（Linux Virtual System）设计，专门监控集群系统中各个服务节点的状态根据TCP/IP参考模型 第三、第四、第五层交换机制检测每个服务节点的状态（详细见本页keepalived工作原理） e.g: keepalived检测WEB服务器的状态如果一台WEB服务器死机/工作出现故障，keepalived检测到此状况后会将故障服务器从系统中剔除；直至该服务器工作正常后keepalived自动将该服务器加入到服务器群中； 以上工作keepalived自动完成，无需人工干涉，人工干预仅是修复出现故障的服务节点； keepalived 后续加入了VRRP功能VRRP（Virtaul Router Redunadancy Protocol，虚拟路由器冗余协议） 目的：解决静态路由出现的单点故障问题，实现网络不间断稳定运行 VRRP 协议与工作原理❉ 引入VRRP概念 说明：图片来源百度百科；左侧图片为局域网组网；右侧图片为VRRP组网 局域网组网 e.g : 网络内的所有主机会设置一条默认网关（10.100.10.1），当主机发出的目的地址不在本网段（10.100.10.0/24）的报文；通过默认网关发往路由器A，从而实现主机与外部网络的通信 该组网缺点：当路由器A坏掉时，本网段内通过以RA为默认网关下一跳的主机将断掉与外界的通信，产生单点故障 VRRP组网 e.g : RA：Master 活动路由器 —&gt;10.100.10.2RB：Backup 备份路由器 —&gt;10.100.10.3VRIP : 虚拟路由器IP —-&gt;10.100.10.1 VRRP将局域网中的一组路由器【 RA和RB】组成一个虚拟路由器——&gt;&gt;&gt;备份组 虚拟路由器拥有自己的IP地址 10.100.10.1局域网内的主机仅知道虚拟路由器IP地址为10.100.10.1，不知道具体的Master与Backup路由器IP局域网内的主机将默认网关下一跳的地址设置为该虚拟路由器IP地址，通过该地址与其他网络进行通信 该组网优点：当备份组内的Master路由器DOWN掉，会进行选举策略选出一个新的Master路由器，继续往网络内的主机提供路由服务，从而实现网络内的主机不间断地与外部网络进行通信 ❉ VRRP 协议 VRRP：解决局域网中配置静态网关出现单点失效的路由协议 设计目标：网络发生故障时透明地进行设备切换而不影响主机间的数据通信 ❉ VRRP 工作原理 VRRP协议将两台或多台路由器设备虚拟成一个虚拟路由器，对外提供虚拟路由器IP(一个或多个)； 而在路由器组内部，如果实际拥有这个对外IP的路由器如果工作正常的话就是MASTER，或者是通过算法选举产生；MASTER实现针对虚拟路由器IP的各种网络功能，如ARP请求，ICMP，以及数据的转发等； 其他设备不拥有该IP，状态是BACKUP，除了接收MASTER的VRRP状态通告信息外，不执行对外的网络功能。 当主机失效时，BACKUP将接管原先MASTER的网络功能。 ❀ 如何判定多个路由器在同一组虚拟路由器中？ VRID：每个虚拟路由器都有一个唯一标识（VRID是一个0～255的正整数）;配置VRRP协议时需要配置每个路由器的虚拟路由器ID(VRID)和优先权值;使用VRID将路由器进行分组，具有相同VRID值的路由器为同一个组 ❀ BACKUP 为什么没有发生抢占？ VRRP通告:它使用IP多播数据包进行封装，组地址为224.0.0.18，发布范围只限于同一局域网内;在一个虚拟路由器中，只有处于MASTER角色的路由器会一直发送VRRP通告信息；处于BACKUP状态的路由器只接收MASTER发过来的报文信息，用来监控MASTER运行状态; 除非它的优先级比MASTER更高 ❀ 什么时候发生选举？ 当MASTER不可用时，BACKUP无法收到MASTER发过来的报文信息；认定MASTER出现故障，然后多台BACKUP就开始进行选举； ❀ Master选举 虚拟路由器IP=路由器本身配置IP该路由器始终将是MASTER；IP地址所有者自动具有最高优先级：255 优先级选举主控路由器（优先级范围是0—255）优先级0一般用在IP地址所有者主动放弃主控者角色时使用。可配置的优先级范围为1—254 优先级相等，则比较路由器的实际IP，IP值较大的优先权高 ❉ VRRP 应用实例123456789101112131415161718192021222324252627282930 +-----------+ +-----------+ | Rtr1 | | Rtr2 | |(MR VRID=1)| |(BR VRID=1)| |(BR VRID=2)| |(MR VRID=2)| VRID=1 +-----------+ +-----------+ VRID=2 IP A ----------&gt;* *&lt;---------- IP B | | | | ------------------+------------+-----+--------+--------+--------+-- ^ ^ ^ ^ | | | | (IP A) (IP A) (IP B) (IP B) | | | | +--+--+ +--+--+ +--+--+ +--+--+ | H1 | | H2 | | H3 | | H4 | +-----+ +-----+ +--+--+ +--+--+ Legend: ---+---+---+-- = Ethernet, Token Ring, or FDDI H = Host computer MR = Master Router BR = Backup Router * = IP Address (IP) = default router for hosts----------------------------------------------------------------- + VRID 1 | Rtr1（Master） | Rtr2（Backup） + 正常情况下 H1与H2走R1;反之 走R2 + VRID 2 | Rtr1（Backup） | Rtr2 （Master） + 正常情况下 H3与H4走R2;反之 走R1 keepalived 安装 实验需求：安装keepalived（仅安装） 实验实现：服务器：CentOS 6.5-minimal软 件：Keepalived ( V_1.2.19 ) 安装过程：123456789101112# 下载安装包并解压，查看相关参数[root@lucia tmp]# wget http://www.keepalived.org/software/keepalived-1.2.19.tar.gz # 下载Keepalived安装包[root@lucia tmp]# tar -zxf keepalived-1.2.19.tar.gz #解压安装包[root@lucia tmp]# cd keepalived-1.2.19[root@lucia keepalived-1.2.19]# ./configure --help #查看confiure编译参数 #================================================# 指定安装在/etc/ &#123;--sysconfdir=/etc&#125;# 指定使用内核源码中的头文件 &#123;--with-kernel-dir&#125;# 注：使用LVS时，需要用到&quot;--with-kernel-dir&quot;#=============================================== 编译安装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657[root@lucia keepalived-1.2.19]# [ -z /usr/src/kernels/ ] &amp;&amp; yum -y install kernel-headers kernel-devel || echo &quot;The kernel file already exists&quot;The kernel file already exists#===========================# 判断kernels目录是否存在文件#=========================== [root@lucia keepalived-1.2.19]# ./configure --sysconfdir=/etc/ --with-kernel-dir=/usr/src/kernels/2.6.32-573.12.1.el6.x86_64 #============================================================================# ./configure 对即将安装的软件进行配置，检查当前的环境是否满足要安装软件的依赖关系#============================================================================configure: error: in `/tmp/keepalived-1.2.19&apos;:configure: error: no acceptable C compiler found in $PATHSee `config.log&apos; for more details #============================================================================# 报错：gcc编译器没有安装# [root@lucia keepalived-1.2.19]# yum -y install gcc#============================================================================= 继续返回上一步预安装./configure[root@lucia keepalived-1.2.19]# ./configure --sysconfdir=/etc/ --with-kernel-dir=/usr/src/kernels/2.6.32-573.12.1.el6.x86_64 configure: error:!!! OpenSSL is not properly installed on your system. !!!!!! Can not include OpenSSL headers files. !!! #=========================================================================# 报错：OpenSSL 没有安装# [root@lucia keepalived-1.2.19]# yum -y install openssl*#=========================================================================./configure 成功后，显示是Keepalived 输出的加载模块信息Keepalived configuration------------------------Keepalived version : 1.2.19 Compiler : gccCompiler flags : -g -O2Extra Lib : -lssl -lcrypto -lcrypt Use IPVS Framework : YesIPVS sync daemon support : YesIPVS use libnl : Nofwmark socket support : YesUse VRRP Framework : YesUse VRRP VMAC : YesSNMP support : NoSHA1 support : NoUse Debug flags : No[root@lucia keepalived-1.2.19]# make &amp;&amp; make install #编译&amp;&amp;安装[root@lucia keepalived-1.2.19]# ln -s /usr/local/sbin/keepalived /sbin/ #软链接到系统使用的管理程序目录中[root@lucia keepalived-1.2.19]# chkconfig --add keepalived #添加到系统服务[root@lucia keepalived-1.2.19]# chkconfig --level 35 keepalived on #添加到开机启动 ❉ Keepalived 配置详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131[root@lucia keepalived-1.2.19]# cd /etc/keepalived/[root@lucia keepalived-1.2.19]# lskeepalived.conf samples# ================================================================# Keepalived 配置文件路径为/etc/keepalived/keepalived.conf# samples 目录下存放着keepalived配置的示例# ================================================================#============================================================# keepalived.conf 配置#------------------------------------------------------------# 1、Keepalived 配置文件以block形式组织，每个块内容都包含在&#123;&#125;# 2、“#” “!” 开头行为注释# 3、keepalived 配置为三类：# 全局配置:对整个keepalived都生效的配置 # VRRPD 配置:核心配置，主要实现keepalived高可用功能# LVS配置#============================================================! Configuration File for keepalived ######################### 全局配置######################## global_defs &#123; # global_defs 全局配置标识 ------------------------------------------ notification_email &#123; # notification_email用于设置报警邮件地址 acassen@firewall.loc # 可以设置多个，每行一个 failover@firewall.loc # 设置邮件报警，需开启本机Sendmail 服务 sysadmin@firewall.loc # yum -y install mailx sendmail &#125; ---------------------------------------------- notification_email_from Alexandre.Cassen@firewall.loc # 设置邮件发送地址 smtp_server 192.168.200.1 # 设置邮件的smtp server地址 smtp_connect_timeout 30 # 设置连接smtp sever超时时间 router_id LVS_DEVEL # 表示运行keepalived服务器标识，发邮件时显示在邮件主题中的信息&#125;####################### VRRPD配置######################vrrp_instance VI_1 &#123; # VRRPD 配置标识 VI_1是实例名称 state MASTER # 指定Keepalvied角色 MASTER表示此主机为主服务器 BACKUP则是表示为备用服务器 interface eth0 # 指定 HA 监测网络的接口 virtual_router_id 51 # 虚拟路由标识，标识为数字，同一个VRRP实例使用唯一的标识，即可表示在同一个vrrp_instance下 MASTER_ID = BACKUP_ID priority 100 # 定义节点优先级，数字越大表示节点的优先级越高，同一个VRRP_instance下，MASTE_PRIORITY &gt; BACKUP_PRIORITY advert_int 1 # 设定MASTER与BACKUP主机质检同步检查的时间间隔，单位为秒 authentication &#123; # 设定节点间通信验证类型和密码，验证类型主要有PASS和AH两种 auth_type PASS # 同一个vrrp_instance，MASTER验证密码和BACKUP保持一致 auth_pass 1111 &#125; virtual_ipaddress &#123; # 设置虚拟IP地址 (VIP),又叫做漂移IP地址 192.168.200.16 192.168.200.17 192.168.200.18 &#125;#-------------------------------------------------------------------------------# 问：为什么叫漂移IP地址？# 答：当Keepalived切换到MASTER状态时，IP地址会自动添加到系统中# 当Keepalvied切换到BACKUP状态时，IP地址将自动从系统中删除# # keepalived通过“ip address add”命令的形式将VIP添加到系统# 通过“ip add”查看系统中添加的VIP地址#--------------------------------------------------------------------------------&#125;####################### LVS配置######################virtual_server 192.168.200.100 443 &#123; # virtual_server LVS配置标识 # 格式：virtual_server VIP port [IP 和 port 之间空格隔开] delay_loop 6 # 设置健康检查时间间隔，单位为秒 lb_algo rr # 设置负载调度算法，可用的调度算法有：rr、wlc、lc、lblc、sh、dh等 lb_kind NAT # 设置LVS实现负载均衡的机制，有NAT、TUN和DR三种模式可选 nat_mask 255.255.255.0 # NAT子网掩码 persistence_timeout 50 # 会话保持时间 protocol TCP # 指定转发协议类型#----------------------------------------------------------------------------------------------------# persistence_timeout 会话保持时间对动态网页非常有用，为集群系统中的seesion共享提供了一个很好的解决方案# 用户的请求会一直分发到某个服务节点，直至超过这个会话的保持时间（指最大无响应超时时间）# =[用户操作动态页面如果在50s没有执行任何操作则被分发到另外的节点]#---------------------------------------------------------------------------------------------------- real_server 192.168.201.100 443 &#123; # 设置real server段开始的标识 [ IP为真实IP地址] # 格式：real_server realIP port [IP 和 port 之间空格隔开] ----------------------------------------------------------------- weight 1 # 用于配置real server节点的权值，权值大小用数字表示，数字越大，权值越高 # 设置权值大小可以为不同性能的服务器分配不同的负载 ------------------------------------------------------------------ SSL_GET &#123; # 健康检查 SSL_GET url &#123; # 指定SSL检查的URL信息，可以指定多个 path /index.html # 后跟详细的URL路径 digest ff20ad2481f97b1754ef3e12ecd3a9cc # SSL检查后的摘要信息，可以通过genhash命令工具获取#-----------------------------------------------------------------# [root@lucia keepalived]# genhash -s 192.168.201.100 -p 80 -u /index.html#----------------------------------------------------------------- &#125; url &#123; path /mrtg/ digest 9b3a0c85a887a256d6939da88aabd8cd &#125; connect_timeout 3 # 表示无响应超时时间，单位为秒 nb_get_retry 3 # 表示重试次数 delay_before_retry 3 # 表示充实间隔 &#125; &#125;&#125; virtual_server 10.10.10.2 1358 &#123; delay_loop 6 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP sorry_server 192.168.200.200 1358 # 备份节点，在所有real serer失效后，启用备份节点&#125; VRRP原理参考文档如下： http://bbs.nanjimao.com/thread-790-1-1.html （此篇写的很好） http://blog.chinaunix.net/uid-26575352-id-3529109.html keepalived.conf 参考书籍 《高性能Linux服务器构建实战》","tags":[{"name":"keepalived","slug":"keepalived","permalink":"http://yoursite.com/tags/keepalived/"}]}]